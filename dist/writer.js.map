{
  "version": 3,
  "sources": [
    "../node_modules/browser-pack/_prelude.js",
    "../src/parser.js",
    "../src/util.js",
    "../src/writer.js"
  ],
  "names": [],
  "mappings": "AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA",
  "file": "generated.js",
  "sourceRoot": "",
  "sourcesContent": [
    "(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})",
    "'use strict'\n\nconst map = require('./util').map\n\nif(!Node) {\n  const Node = {\n    ELEMENT_NODE: 1,\n    TEXT_NODE: 3\n  }\n}\n\n// export\nparser.serialize = serialize\nmodule.exports = exports = parser\n\nfunction serialize(tokens) {\n  return JSON.stringify(tokens, replacer)\n}\n\nfunction replacer(key, value) {\n  let blacklist = ['nextSibling', 'previousSibling']\n  return blacklist.indexOf(key) === -1 ? value : undefined\n}\n\n/**\n * Parses tokens into a graph with \"writable\" objects\n * @param {Node[]|NodeList|Iterable<Node>} tokens\n * @return {Writer}\n */\nfunction parser(tokens) {\n  return map(textFactory, tokens)\n    .reduce(treeBuilder, [])\n}\n\n/**\n * Creates \"writable\" text objects\n * @param {Node} node\n * @return {Object}\n */\nfunction textFactory(node) {\n  return {\n    // node,\n    nodeName: node.nodeName,\n    nodeType: node.nodeType,\n    childNodes: node.childNodes,\n    get textContent() {\n      return node.textContent\n    },\n    set textContent(value) {\n      node.textContent = value\n    },\n    get textLength() {\n      return node.textContent.length\n    },\n    previousSibling: undefined,\n    nextSibling: undefined\n  }\n}\n\nfunction treeBuilder(tree, text) {\n  switch(text.nodeType) {\n    case Node.ELEMENT_NODE:\n      tree.push(text)\n      if(text.childNodes.length)\n        text.childNodes = parser(text.childNodes)\n      break\n    case Node.TEXT_NODE:\n      text.textContent.trim() === '' || tree.push(text)\n      break\n  }\n\n  text.previousSibling = tree[tree.length - 2]\n  if(text.previousSibling) text.previousSibling.nextSibling = text\n\n  return tree\n}\n",
    "'use strict'\n\nmodule.exports = {\n  map\n}\n\nfunction map(f, iterable) {\n  return Array.prototype.map.call(iterable, x => f(x))\n}\n",
    "'use strict'\n\nconst parser = require('./parser')\nconst map = require('./util').map\n\nmain()\n\nfunction main() {\n  // TODO: create function that get the selected element + its childNodes\n  let entry = document.querySelector('#test3')\n  document.addEventListener(\"click\", bind(writeStatus, entry, '<strong>This</strong> is freaking <i>AWESOME!</i>'), false)\n\n  function bind(f /*,args*/) {\n    let args = [].slice.call(arguments)\n    return f.bind.apply(f, args)\n  }\n\n  function writeStatus(entry, msg) {\n    let entryStatus = [].slice.call(entry.children)\n    entryStatus.forEach(function(status) {\n      eraseText(status, 40, function() {\n        writeText(status, msg, 60)\n      })\n    })\n  }\n}\n\nfunction eraseText(el, speed, cb) {\n  let text = writer( parser(el.childNodes) )\n  // let textLength = text.textLength\n  let n = el.textContent.length\n  let timer = setInterval(() => {\n    text.erase(1)\n    //el.textContent = el.textContent.slice(0, -1)\n    n--\n    if(n === 0) {\n      clearInterval(timer)\n      // el.dataset.writing = 0\n      cb && cb()\n    }\n  }, speed)\n}\n\nfunction writeText(el, html, speed, cb) {\n  let clone = el.cloneNode(false)\n  clone.innerHTML = html\n  let text = writer( parser(clone.childNodes) )\n  let n = 0, max = clone.textContent.length // text.textLength\n  let timer = setInterval(() => {\n    text.add(el, 1)\n    n++\n    if(n === max) {\n      clearInterval(timer)\n      // el.dataset.writing = 0\n      cb && cb()\n    }\n  }, speed)\n}\n\nfunction writer(writables) {\n  let eraseCurrent = last(writables)\n  let writeCurrent = first(writables)\n  let cursor = 0//, end = writables.textLength\n  let placeholder\n  return {\n    get textLength() { // TODO: Maybe you could just call textContent.length on the root node you pass to the parser\n      return map(x => x.textLength, writables)\n        .reduce((a,b) => a + b)\n    },\n    add(el, n) {\n      if(!placeholder) placeholder = el\n      if(writeCurrent.textLength === cursor) {\n        writeCurrent = writeCurrent.nextSibling\n\n        if(writeCurrent.textLength === 0) {\n          this.add(el, n) // skip element\n          return\n        } else if(writeCurrent.nodeType === Node.ELEMENT_NODE) {\n          placeholder = document.createElement(writeCurrent.nodeName)\n        } else if(writeCurrent.nodeType === Node.TEXT_NODE) {\n          placeholder = document.createTextNode('')\n        }\n\n        el.appendChild(placeholder)\n        cursor = 0\n      }\n\n      placeholder.textContent += writeCurrent.textContent[cursor]\n      cursor += n\n    },\n    erase(n) {\n      if(!eraseCurrent) return\n      if(eraseCurrent.textLength === 0) {\n        eraseCurrent = eraseCurrent.previousSibling\n        this.erase(n) // skip element\n        return\n      }\n\n      eraseCurrent.textContent = eraseCurrent.textContent.slice(0, -n)\n    }\n  }\n}\n\nfunction last(indexed) {\n  return indexed[indexed.length - 1]\n}\n\nfunction first(indexed) {\n  return indexed[0]\n}\n\n\n\n/* TESTS */\n// let tokens1 = document.getElementById(\"test1\").childNodes\n// let tree1 = parser( tokens1 )\n\n// let tokens2 = document.getElementById(\"test2\").childNodes\n// let tree2 = parser( tokens2 )\n\n// let tokens3 = document.getElementById(\"test3\").childNodes\n// let tree3 = parser( tokens3 )\n\n// let json1 = parser.serialize(tree1)\n// let json2 = parser.serialize(tree2)\n// let json3 = parser.serialize(tree3)\n// console.log(json1)\n// console.log(json2)\n// console.log(json3)\n//\n// let entry = document.querySelector('.entry')\n// document.addEventListener(\"click\", bind(writeStatus, entry, 'Document <i>is</i> clicked'), false)\n// setTimeout(bind(eraseText, entry.querySelector('.entry__status'), 60), 500)\n// setTimeout(bind(writeStatus, entry, 'Hello <span>World</span>'), 1000)\n"
  ]
}