{"version":3,"sources":["../node_modules/browser-pack/_prelude.js","../src/parser.js","../src/util.js","../src/writer.js"],"names":["e","t","n","r","s","o","u","a","require","i","f","Error","code","l","exports","call","length","1","module","parser","tokens","map","textFactory","reduce","treeBuilder","node","nodeName","nodeType","childNodes","textContent","value","textLength","previousSibling","nextSibling","tree","text","Node","ELEMENT_NODE","push","TEXT_NODE","trim","tree1","document","getElementById","blacklist","console","log","JSON","stringify","key","indexOf","undefined","iterable","Array","prototype","x","eraseText","el","speed","cb","writer","timer","setInterval","remove","clearInterval","writeText","html","clone","cloneNode","innerHTML","max","add","writables","placeholder","eraseCurrent","last","writeCurrent","first","current","b","[object Object]","createElement","appendChild","this","slice","indexed","bind","args","arguments","apply","writeStatus","entry","msg","querySelectorAll","forEach","status","classList","querySelector","addEventListener","setTimeout"],"mappings":"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","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","'use strict'\n\nconst map = require('./util').map\n\n/* TESTS */\n\n// TODO: create function that get the selected element + its childNodes\nlet tokens1 = document.getElementById(\"test1\").childNodes\nlet tree1 = parser( tokens1 )\n\n// let tokens2 = document.getElementById(\"test2\").childNodes\n// let tree2 = parser( tokens2 )\n\n// let tokens3 = document.getElementById(\"test3\").childNodes\n// let tree3 = parser( tokens3 )\nlet blacklist = ['nextSibling', 'previousSibling']\nconsole.log(\n  JSON.stringify(tree1, (key, value) => blacklist.indexOf(key) === -1 ? value : undefined\n  )\n)\n// console.log(JSON.stringify(tree2))\n// console.log(JSON.stringify(tree3))\n\n\nmodule.exports = exports = parser\n\n/**\n * Parses tokens into a graph with \"writable\" objects\n * @param {Node[]|NodeList|Iterable<Node>} tokens\n * @return {Writer}\n */\nfunction parser(tokens) {\n  return map(textFactory, tokens)\n    .reduce(treeBuilder, [])\n}\n\n/**\n * Creates \"writable\" text objects\n * @param {Node} node\n * @return {Object}\n */\nfunction textFactory(node) {\n  return {\n    // node,\n    nodeName: node.nodeName,\n    nodeType: node.nodeType,\n    childNodes: node.childNodes,\n    get textContent() {\n      return node.textContent\n    },\n    set textContent(value) {\n      node.textContent = value\n    },\n    get textLength() {\n      return node.textContent.length\n    },\n    previousSibling: null,\n    nextSibling: null\n  }\n}\n\nfunction treeBuilder(tree, text) {\n  switch(text.nodeType) {\n    case Node.ELEMENT_NODE:\n      tree.push(text)\n      if(text.childNodes.length)\n        text.childNodes = parser(text.childNodes)\n      break\n    case Node.TEXT_NODE:\n      text.textContent.trim() === '' || tree.push(text)\n      break\n  }\n\n  text.previousSibling = tree[tree.length - 2]\n  if(text.previousSibling) text.previousSibling.nextSibling = text\n\n  return tree\n}\n","'use strict'\n\nmodule.exports = {\n  map\n}\n\nfunction map(f, iterable) {\n  return Array.prototype.map.call(iterable, x => f(x))\n}\n","'use strict'\n\nconst parser = require('./parser')\nconst map = require('./util').map\n\nmain()\n\nfunction main() {\n  let entry = document.querySelector('.entry')\n\n  document.addEventListener(\"click\", bind(writeStatus, entry, 'Document is clicked'), false)\n  setTimeout(bind(writeStatus, entry, 'Hello <span>World</span>'), 1000)\n  // setTimeout(bind(eraseText, entry.querySelector('.entry__status'), 60), 500)\n\n  function bind(f /*,args*/) {\n    var args = [].slice.call(arguments)\n    return f.bind.apply(f, args)\n  }\n\n  function writeStatus(entry, msg) {\n    let entryStatus = entry.querySelectorAll(\".entry__status\")\n    entryStatus.forEach(function(status) {\n      eraseText(status, 40, function(){\n        status.classList.add('entry__status_active')\n        writeText(status, msg, 60)\n      })\n    })\n  }\n}\n\nfunction eraseText(el, speed, cb) {\n  let text = writer( parser(el.childNodes) )\n  // let textLength = text.textLength\n  let n = el.textContent.length\n  let timer = setInterval(() => {\n    text.remove(1)\n    //el.textContent = el.textContent.slice(0, -1)\n    n--\n    if(n === 0) {\n      clearInterval(timer)\n      // el.dataset.writing = 0\n      cb && cb()\n    }\n  }, speed)\n}\n\nfunction writeText(el, html, speed, cb) {\n  let clone = el.cloneNode(false)\n  clone.innerHTML = html\n  let text = writer( parser(clone.childNodes) )\n  let n = 0, max = clone.textContent.length // text.textLength\n  let timer = setInterval(() => {\n    text.add(el, 1)\n    n++\n    if(n === max) {\n      clearInterval(timer)\n      // el.dataset.writing = 0\n      cb && cb()\n    }\n  }, speed)\n}\n\nfunction writer(writables) {\n  let eraseCurrent = last(writables)\n  let writeCurrent = first(writables)\n  let current = 0//, end = writables.textLength\n  let placeholder\n  return {\n    get textLength() { // Maybe you could just call textContent.length on the root node you pass to the parser\n      return map(x => x.textLength, writables)\n        .reduce((a,b) => a + b)\n    },\n    add(el, n) {\n      if(!placeholder) placeholder = el\n      if(writeCurrent.textLength === current) {\n        writeCurrent = writeCurrent.nextSibling\n\n        placeholder = document.createElement(writeCurrent.nodeName)\n        el.appendChild(placeholder)\n\n        current = 0\n      }\n\n      placeholder.textContent += writeCurrent.textContent[current]\n      current += n\n    },\n    remove(n) {\n      if(!eraseCurrent) return\n      if(eraseCurrent.textLength === 0) {\n        eraseCurrent = eraseCurrent.previousSibling\n        this.remove(n)\n        return\n      }\n\n      eraseCurrent.textContent = eraseCurrent.textContent.slice(0, -n)\n    }\n  }\n}\n\nfunction last(indexed) {\n  return indexed[indexed.length - 1]\n}\n\nfunction first(indexed) {\n  return indexed[0]\n}\n"]}